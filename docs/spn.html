<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>cryptanalysis.spn API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>cryptanalysis.spn</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from math import log2

__all__ = [&#34;rotate_left&#34;, &#34;gen_pbox&#34;, &#34;SPN&#34;]

def rotate_left(val, shift, mod):
    &#34;&#34;&#34;
    Rotate the bits of the value to the left by the shift amount.

    The function rotates the bits of the value to the left by the shift amount,
    wrapping the bits that overflow. The result is then masked by (1&lt;&lt;mod)-1
    to only keep the mod number of least significant bits.

    :param val: Integer, the value to be rotated.
    :param shift: Integer, the number of places to shift the value to the left.
    :param mod: Integer, the modulo to be applied on the result.
    :return: Integer, the rotated value.
    &#34;&#34;&#34;
    shift = shift % mod
    return (val &lt;&lt; shift | val &gt;&gt; (mod - shift)) &amp; ((1 &lt;&lt; mod) - 1)

def gen_pbox(s, n):
    &#34;&#34;&#34;
    Generate a balanced permutation box for an SPN

    :param s: Integer, number of bits per S-box.
    :param n: Integer, number of S-boxes.
    :return: List of integers, representing the generated P-box.
    &#34;&#34;&#34;
    return [(s * i + j) % (n * s) for j in range(s) for i in range(n)]


class SPN:
    def __init__(self, SBOX, PBOX, key, rounds, implementation=0):
        &#34;&#34;&#34;
        Initialize the SPN class with the provided parameters.

        :param SBOX: List of integers representing the S-box.
        :param PBOX: List of integers representing the P-box.
        :param key: List of integers, bytes or bytearray representing the key.
                    LSB BLOCK_SIZE bits will be used
        :param rounds: Integer, number of rounds for the SPN.
        :param implementation: Integer (0 or 1), optional, default is 0.
                               0: Last round doesn&#39;t contain the permute operation.
                               1: Last round contains the permute operation.
        &#34;&#34;&#34;
        self.SBOX = SBOX
        self.PBOX = PBOX
        self.SINV = [SBOX.index(i) for i in range(len(SBOX))]
        self.PINV = [PBOX.index(i) for i in range(len(PBOX))]
        self.BLOCK_SIZE = len(PBOX)
        self.BOX_SIZE = int(log2(len(SBOX)))
        self.NUM_SBOX = len(PBOX) // self.BOX_SIZE
        self.rounds = rounds
        self.round_keys = self.expand_key(key, rounds)
        if implementation == 0:
            self.encrypt = self._enc_last_noperm
            self.decrypt = self._dec_last_noperm
        else:
            self.encrypt = self._enc_last_withperm
            self.decrypt = self._dec_last_withperm

    def perm(self, inp: int) -&gt; int:
        &#34;&#34;&#34;
        Apply the P-box permutation on the input.

        :param inp: Integer, the input value to apply the P-box permutation on.
        :return: Integer, the permuted value after applying the P-box.
        &#34;&#34;&#34;
        ct = 0
        for i, v in enumerate(self.PBOX):
            ct |= (
                inp &gt;&gt; (
                    self.BLOCK_SIZE -
                    1 -
                    i) &amp; 1) &lt;&lt; (
                self.BLOCK_SIZE -
                1 -
                v)
        return ct

    def inv_perm(self, inp: int) -&gt; int:
        &#34;&#34;&#34;
        Apply the inverse P-box permutation on the input.

        :param inp: Integer, the input value to apply the inverse P-box permutation on.
        :return: Integer, the permuted value after applying the inverse P-box.
        &#34;&#34;&#34;
        ct = 0
        for i, v in enumerate(self.PINV):
            ct |= (
                inp &gt;&gt; (
                    self.BLOCK_SIZE -
                    1 -
                    i) &amp; 1) &lt;&lt; (
                self.BLOCK_SIZE -
                1 -
                v)
        return ct

    def sbox(self, inp: int) -&gt; int:
        &#34;&#34;&#34;
        Apply the S-box substitution on the input.

        :param inp: Integer, the input value to apply the S-box substitution on.
        :return: Integer, the substituted value after applying the S-box.
        &#34;&#34;&#34;
        ct, BS = 0, self.BOX_SIZE
        for i in range(self.NUM_SBOX):
            ct |= self.SBOX[(inp &gt;&gt; (i * BS)) &amp; ((1 &lt;&lt; BS) - 1)] &lt;&lt; (BS * i)
        return ct

    def inv_sbox(self, inp: int) -&gt; int:
        &#34;&#34;&#34;
        Apply the inverse S-box substitution on the input.

        :param inp: Integer, the input value to apply the inverse S-box substitution on.
        :return: Integer, the substituted value after applying the inverse S-box.
        &#34;&#34;&#34;
        ct, BS = 0, self.BOX_SIZE
        for i in range(self.NUM_SBOX):
            ct |= self.SINV[(inp &gt;&gt; (i * BS)) &amp; ((1 &lt;&lt; BS) - 1)] &lt;&lt; (BS * i)
        return ct

    def int_to_list(self, inp):
        &#34;&#34;&#34;
        Convert a len(PBOX)-sized integer to a list of S-box sized integers.

        :param inp: Integer, representing a len(PBOX)-sized input.
        :return: List of integers, each representing an S-box sized input.
        &#34;&#34;&#34;
        BS = self.BOX_SIZE
        return [(inp &gt;&gt; (i * BS)) &amp; ((1 &lt;&lt; BS) - 1)
                for i in range(self.NUM_SBOX - 1, -1, -1)]

    def list_to_int(self, lst):
        &#34;&#34;&#34;
        Convert a list of S-box sized integers to a len(PBOX)-sized integer.

        :param lst: List of integers, each representing an S-box sized input.
        :return: Integer, representing the combined input as a len(PBOX)-sized integer.
        &#34;&#34;&#34;
        res = 0
        for i, v in enumerate(lst[::-1]):
            res |= v &lt;&lt; (i * self.BOX_SIZE)
        return res

    def expand_key(self, key, rounds):
        &#34;&#34;&#34;
        Derive round keys deterministically from the given key.

        :param key: List of integers, bytes, or bytearray representing the key.
        :param rounds: Integer, number of rounds for the SPN.
        :return: List of integers, representing the derived round keys.
        &#34;&#34;&#34;
        if isinstance(key, list):
            key = self.list_to_int(key)
        elif isinstance(key, (bytes, bytearray)):
            key = int.from_bytes(key, &#39;big&#39;)
        block_mask = (1 &lt;&lt; self.BLOCK_SIZE) - 1
        key = key &amp; block_mask
        keys = [key]
        for _ in range(rounds):
            keys.append(self.sbox(rotate_left(
                keys[-1], self.BOX_SIZE + 1, self.BLOCK_SIZE)))
        return keys

    def _enc_last_noperm(self, pt: int) -&gt; int:
        &#34;&#34;&#34;
        Encrypt plaintext using the SPN, where the last round doesn&#39;t contain the permute operation.

        :param pt: Integer, plaintext input to be encrypted.
        :return: Integer, ciphertext after encryption.
        &#34;&#34;&#34;
        ct = pt ^ self.round_keys[0]
        for round_key in self.round_keys[1:-1]:
            ct = self.sbox(ct)
            ct = self.perm(ct)
            ct ^= round_key
        ct = self.sbox(ct)
        return ct ^ self.round_keys[-1]

    def _enc_last_withperm(self, ct: int) -&gt; int:
        &#34;&#34;&#34;
        Encrypt plaintext using the SPN, where the last round contains the permute operation.
        Note, the last permutation provides no additional security

        :param pt: Integer, plaintext input to be encrypted.
        :return: Integer, ciphertext after encryption.
        &#34;&#34;&#34;
        for round_key in self.round_keys[:-1]:
            ct ^= round_key
            ct = self.sbox(ct)
            ct = self.perm(ct)
        return ct ^ self.round_keys[-1]

    def _dec_last_noperm(self, ct: int) -&gt; int:
        &#34;&#34;&#34;
        Decrypt ciphertext using the SPN, where the last round doesn&#39;t contain the permute operation.

        :param ct: Integer, ciphertext input to be decrypted.
        :return: Integer, plaintext after decryption.
        &#34;&#34;&#34;
        ct = ct ^ self.round_keys[-1]
        ct = self.inv_sbox(ct)
        for rk in self.round_keys[-2:0:-1]:
            ct ^= rk
            ct = self.inv_perm(ct)
            ct = self.inv_sbox(ct)
        return ct ^ self.round_keys[0]

    def _dec_last_withperm(self, ct: int) -&gt; int:
        &#34;&#34;&#34;
        Decrypt ciphertext using the SPN, where the last round contains the permute operation.

        :param ct: Integer, ciphertext input to be decrypted.
        :return: Integer, plaintext after decryption.
        &#34;&#34;&#34;
        ct = ct ^ self.round_keys[-1]
        for rk in self.round_keys[-2::-1]:
            ct = self.inv_perm(ct)
            ct = self.inv_sbox(ct)
            ct ^= rk
        return ct</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="cryptanalysis.spn.gen_pbox"><code class="name flex">
<span>def <span class="ident">gen_pbox</span></span>(<span>s, n)</span>
</code></dt>
<dd>
<div class="desc"><p>Generate a balanced permutation box for an SPN</p>
<p>:param s: Integer, number of bits per S-box.
:param n: Integer, number of S-boxes.
:return: List of integers, representing the generated P-box.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def gen_pbox(s, n):
    &#34;&#34;&#34;
    Generate a balanced permutation box for an SPN

    :param s: Integer, number of bits per S-box.
    :param n: Integer, number of S-boxes.
    :return: List of integers, representing the generated P-box.
    &#34;&#34;&#34;
    return [(s * i + j) % (n * s) for j in range(s) for i in range(n)]</code></pre>
</details>
</dd>
<dt id="cryptanalysis.spn.rotate_left"><code class="name flex">
<span>def <span class="ident">rotate_left</span></span>(<span>val, shift, mod)</span>
</code></dt>
<dd>
<div class="desc"><p>Rotate the bits of the value to the left by the shift amount.</p>
<p>The function rotates the bits of the value to the left by the shift amount,
wrapping the bits that overflow. The result is then masked by (1&lt;&lt;mod)-1
to only keep the mod number of least significant bits.</p>
<p>:param val: Integer, the value to be rotated.
:param shift: Integer, the number of places to shift the value to the left.
:param mod: Integer, the modulo to be applied on the result.
:return: Integer, the rotated value.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rotate_left(val, shift, mod):
    &#34;&#34;&#34;
    Rotate the bits of the value to the left by the shift amount.

    The function rotates the bits of the value to the left by the shift amount,
    wrapping the bits that overflow. The result is then masked by (1&lt;&lt;mod)-1
    to only keep the mod number of least significant bits.

    :param val: Integer, the value to be rotated.
    :param shift: Integer, the number of places to shift the value to the left.
    :param mod: Integer, the modulo to be applied on the result.
    :return: Integer, the rotated value.
    &#34;&#34;&#34;
    shift = shift % mod
    return (val &lt;&lt; shift | val &gt;&gt; (mod - shift)) &amp; ((1 &lt;&lt; mod) - 1)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="cryptanalysis.spn.SPN"><code class="flex name class">
<span>class <span class="ident">SPN</span></span>
<span>(</span><span>SBOX, PBOX, key, rounds, implementation=0)</span>
</code></dt>
<dd>
<div class="desc"><p>Initialize the SPN class with the provided parameters.</p>
<p>:param SBOX: List of integers representing the S-box.
:param PBOX: List of integers representing the P-box.
:param key: List of integers, bytes or bytearray representing the key.
LSB BLOCK_SIZE bits will be used
:param rounds: Integer, number of rounds for the SPN.
:param implementation: Integer (0 or 1), optional, default is 0.
0: Last round doesn't contain the permute operation.
1: Last round contains the permute operation.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SPN:
    def __init__(self, SBOX, PBOX, key, rounds, implementation=0):
        &#34;&#34;&#34;
        Initialize the SPN class with the provided parameters.

        :param SBOX: List of integers representing the S-box.
        :param PBOX: List of integers representing the P-box.
        :param key: List of integers, bytes or bytearray representing the key.
                    LSB BLOCK_SIZE bits will be used
        :param rounds: Integer, number of rounds for the SPN.
        :param implementation: Integer (0 or 1), optional, default is 0.
                               0: Last round doesn&#39;t contain the permute operation.
                               1: Last round contains the permute operation.
        &#34;&#34;&#34;
        self.SBOX = SBOX
        self.PBOX = PBOX
        self.SINV = [SBOX.index(i) for i in range(len(SBOX))]
        self.PINV = [PBOX.index(i) for i in range(len(PBOX))]
        self.BLOCK_SIZE = len(PBOX)
        self.BOX_SIZE = int(log2(len(SBOX)))
        self.NUM_SBOX = len(PBOX) // self.BOX_SIZE
        self.rounds = rounds
        self.round_keys = self.expand_key(key, rounds)
        if implementation == 0:
            self.encrypt = self._enc_last_noperm
            self.decrypt = self._dec_last_noperm
        else:
            self.encrypt = self._enc_last_withperm
            self.decrypt = self._dec_last_withperm

    def perm(self, inp: int) -&gt; int:
        &#34;&#34;&#34;
        Apply the P-box permutation on the input.

        :param inp: Integer, the input value to apply the P-box permutation on.
        :return: Integer, the permuted value after applying the P-box.
        &#34;&#34;&#34;
        ct = 0
        for i, v in enumerate(self.PBOX):
            ct |= (
                inp &gt;&gt; (
                    self.BLOCK_SIZE -
                    1 -
                    i) &amp; 1) &lt;&lt; (
                self.BLOCK_SIZE -
                1 -
                v)
        return ct

    def inv_perm(self, inp: int) -&gt; int:
        &#34;&#34;&#34;
        Apply the inverse P-box permutation on the input.

        :param inp: Integer, the input value to apply the inverse P-box permutation on.
        :return: Integer, the permuted value after applying the inverse P-box.
        &#34;&#34;&#34;
        ct = 0
        for i, v in enumerate(self.PINV):
            ct |= (
                inp &gt;&gt; (
                    self.BLOCK_SIZE -
                    1 -
                    i) &amp; 1) &lt;&lt; (
                self.BLOCK_SIZE -
                1 -
                v)
        return ct

    def sbox(self, inp: int) -&gt; int:
        &#34;&#34;&#34;
        Apply the S-box substitution on the input.

        :param inp: Integer, the input value to apply the S-box substitution on.
        :return: Integer, the substituted value after applying the S-box.
        &#34;&#34;&#34;
        ct, BS = 0, self.BOX_SIZE
        for i in range(self.NUM_SBOX):
            ct |= self.SBOX[(inp &gt;&gt; (i * BS)) &amp; ((1 &lt;&lt; BS) - 1)] &lt;&lt; (BS * i)
        return ct

    def inv_sbox(self, inp: int) -&gt; int:
        &#34;&#34;&#34;
        Apply the inverse S-box substitution on the input.

        :param inp: Integer, the input value to apply the inverse S-box substitution on.
        :return: Integer, the substituted value after applying the inverse S-box.
        &#34;&#34;&#34;
        ct, BS = 0, self.BOX_SIZE
        for i in range(self.NUM_SBOX):
            ct |= self.SINV[(inp &gt;&gt; (i * BS)) &amp; ((1 &lt;&lt; BS) - 1)] &lt;&lt; (BS * i)
        return ct

    def int_to_list(self, inp):
        &#34;&#34;&#34;
        Convert a len(PBOX)-sized integer to a list of S-box sized integers.

        :param inp: Integer, representing a len(PBOX)-sized input.
        :return: List of integers, each representing an S-box sized input.
        &#34;&#34;&#34;
        BS = self.BOX_SIZE
        return [(inp &gt;&gt; (i * BS)) &amp; ((1 &lt;&lt; BS) - 1)
                for i in range(self.NUM_SBOX - 1, -1, -1)]

    def list_to_int(self, lst):
        &#34;&#34;&#34;
        Convert a list of S-box sized integers to a len(PBOX)-sized integer.

        :param lst: List of integers, each representing an S-box sized input.
        :return: Integer, representing the combined input as a len(PBOX)-sized integer.
        &#34;&#34;&#34;
        res = 0
        for i, v in enumerate(lst[::-1]):
            res |= v &lt;&lt; (i * self.BOX_SIZE)
        return res

    def expand_key(self, key, rounds):
        &#34;&#34;&#34;
        Derive round keys deterministically from the given key.

        :param key: List of integers, bytes, or bytearray representing the key.
        :param rounds: Integer, number of rounds for the SPN.
        :return: List of integers, representing the derived round keys.
        &#34;&#34;&#34;
        if isinstance(key, list):
            key = self.list_to_int(key)
        elif isinstance(key, (bytes, bytearray)):
            key = int.from_bytes(key, &#39;big&#39;)
        block_mask = (1 &lt;&lt; self.BLOCK_SIZE) - 1
        key = key &amp; block_mask
        keys = [key]
        for _ in range(rounds):
            keys.append(self.sbox(rotate_left(
                keys[-1], self.BOX_SIZE + 1, self.BLOCK_SIZE)))
        return keys

    def _enc_last_noperm(self, pt: int) -&gt; int:
        &#34;&#34;&#34;
        Encrypt plaintext using the SPN, where the last round doesn&#39;t contain the permute operation.

        :param pt: Integer, plaintext input to be encrypted.
        :return: Integer, ciphertext after encryption.
        &#34;&#34;&#34;
        ct = pt ^ self.round_keys[0]
        for round_key in self.round_keys[1:-1]:
            ct = self.sbox(ct)
            ct = self.perm(ct)
            ct ^= round_key
        ct = self.sbox(ct)
        return ct ^ self.round_keys[-1]

    def _enc_last_withperm(self, ct: int) -&gt; int:
        &#34;&#34;&#34;
        Encrypt plaintext using the SPN, where the last round contains the permute operation.
        Note, the last permutation provides no additional security

        :param pt: Integer, plaintext input to be encrypted.
        :return: Integer, ciphertext after encryption.
        &#34;&#34;&#34;
        for round_key in self.round_keys[:-1]:
            ct ^= round_key
            ct = self.sbox(ct)
            ct = self.perm(ct)
        return ct ^ self.round_keys[-1]

    def _dec_last_noperm(self, ct: int) -&gt; int:
        &#34;&#34;&#34;
        Decrypt ciphertext using the SPN, where the last round doesn&#39;t contain the permute operation.

        :param ct: Integer, ciphertext input to be decrypted.
        :return: Integer, plaintext after decryption.
        &#34;&#34;&#34;
        ct = ct ^ self.round_keys[-1]
        ct = self.inv_sbox(ct)
        for rk in self.round_keys[-2:0:-1]:
            ct ^= rk
            ct = self.inv_perm(ct)
            ct = self.inv_sbox(ct)
        return ct ^ self.round_keys[0]

    def _dec_last_withperm(self, ct: int) -&gt; int:
        &#34;&#34;&#34;
        Decrypt ciphertext using the SPN, where the last round contains the permute operation.

        :param ct: Integer, ciphertext input to be decrypted.
        :return: Integer, plaintext after decryption.
        &#34;&#34;&#34;
        ct = ct ^ self.round_keys[-1]
        for rk in self.round_keys[-2::-1]:
            ct = self.inv_perm(ct)
            ct = self.inv_sbox(ct)
            ct ^= rk
        return ct</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="cryptanalysis.cryptanalysis.Cryptanalysis" href="cryptanalysis.html#cryptanalysis.cryptanalysis.Cryptanalysis">Cryptanalysis</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="cryptanalysis.spn.SPN.expand_key"><code class="name flex">
<span>def <span class="ident">expand_key</span></span>(<span>self, key, rounds)</span>
</code></dt>
<dd>
<div class="desc"><p>Derive round keys deterministically from the given key.</p>
<p>:param key: List of integers, bytes, or bytearray representing the key.
:param rounds: Integer, number of rounds for the SPN.
:return: List of integers, representing the derived round keys.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def expand_key(self, key, rounds):
    &#34;&#34;&#34;
    Derive round keys deterministically from the given key.

    :param key: List of integers, bytes, or bytearray representing the key.
    :param rounds: Integer, number of rounds for the SPN.
    :return: List of integers, representing the derived round keys.
    &#34;&#34;&#34;
    if isinstance(key, list):
        key = self.list_to_int(key)
    elif isinstance(key, (bytes, bytearray)):
        key = int.from_bytes(key, &#39;big&#39;)
    block_mask = (1 &lt;&lt; self.BLOCK_SIZE) - 1
    key = key &amp; block_mask
    keys = [key]
    for _ in range(rounds):
        keys.append(self.sbox(rotate_left(
            keys[-1], self.BOX_SIZE + 1, self.BLOCK_SIZE)))
    return keys</code></pre>
</details>
</dd>
<dt id="cryptanalysis.spn.SPN.int_to_list"><code class="name flex">
<span>def <span class="ident">int_to_list</span></span>(<span>self, inp)</span>
</code></dt>
<dd>
<div class="desc"><p>Convert a len(PBOX)-sized integer to a list of S-box sized integers.</p>
<p>:param inp: Integer, representing a len(PBOX)-sized input.
:return: List of integers, each representing an S-box sized input.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def int_to_list(self, inp):
    &#34;&#34;&#34;
    Convert a len(PBOX)-sized integer to a list of S-box sized integers.

    :param inp: Integer, representing a len(PBOX)-sized input.
    :return: List of integers, each representing an S-box sized input.
    &#34;&#34;&#34;
    BS = self.BOX_SIZE
    return [(inp &gt;&gt; (i * BS)) &amp; ((1 &lt;&lt; BS) - 1)
            for i in range(self.NUM_SBOX - 1, -1, -1)]</code></pre>
</details>
</dd>
<dt id="cryptanalysis.spn.SPN.inv_perm"><code class="name flex">
<span>def <span class="ident">inv_perm</span></span>(<span>self, inp: int) ‑> int</span>
</code></dt>
<dd>
<div class="desc"><p>Apply the inverse P-box permutation on the input.</p>
<p>:param inp: Integer, the input value to apply the inverse P-box permutation on.
:return: Integer, the permuted value after applying the inverse P-box.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def inv_perm(self, inp: int) -&gt; int:
    &#34;&#34;&#34;
    Apply the inverse P-box permutation on the input.

    :param inp: Integer, the input value to apply the inverse P-box permutation on.
    :return: Integer, the permuted value after applying the inverse P-box.
    &#34;&#34;&#34;
    ct = 0
    for i, v in enumerate(self.PINV):
        ct |= (
            inp &gt;&gt; (
                self.BLOCK_SIZE -
                1 -
                i) &amp; 1) &lt;&lt; (
            self.BLOCK_SIZE -
            1 -
            v)
    return ct</code></pre>
</details>
</dd>
<dt id="cryptanalysis.spn.SPN.inv_sbox"><code class="name flex">
<span>def <span class="ident">inv_sbox</span></span>(<span>self, inp: int) ‑> int</span>
</code></dt>
<dd>
<div class="desc"><p>Apply the inverse S-box substitution on the input.</p>
<p>:param inp: Integer, the input value to apply the inverse S-box substitution on.
:return: Integer, the substituted value after applying the inverse S-box.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def inv_sbox(self, inp: int) -&gt; int:
    &#34;&#34;&#34;
    Apply the inverse S-box substitution on the input.

    :param inp: Integer, the input value to apply the inverse S-box substitution on.
    :return: Integer, the substituted value after applying the inverse S-box.
    &#34;&#34;&#34;
    ct, BS = 0, self.BOX_SIZE
    for i in range(self.NUM_SBOX):
        ct |= self.SINV[(inp &gt;&gt; (i * BS)) &amp; ((1 &lt;&lt; BS) - 1)] &lt;&lt; (BS * i)
    return ct</code></pre>
</details>
</dd>
<dt id="cryptanalysis.spn.SPN.list_to_int"><code class="name flex">
<span>def <span class="ident">list_to_int</span></span>(<span>self, lst)</span>
</code></dt>
<dd>
<div class="desc"><p>Convert a list of S-box sized integers to a len(PBOX)-sized integer.</p>
<p>:param lst: List of integers, each representing an S-box sized input.
:return: Integer, representing the combined input as a len(PBOX)-sized integer.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def list_to_int(self, lst):
    &#34;&#34;&#34;
    Convert a list of S-box sized integers to a len(PBOX)-sized integer.

    :param lst: List of integers, each representing an S-box sized input.
    :return: Integer, representing the combined input as a len(PBOX)-sized integer.
    &#34;&#34;&#34;
    res = 0
    for i, v in enumerate(lst[::-1]):
        res |= v &lt;&lt; (i * self.BOX_SIZE)
    return res</code></pre>
</details>
</dd>
<dt id="cryptanalysis.spn.SPN.perm"><code class="name flex">
<span>def <span class="ident">perm</span></span>(<span>self, inp: int) ‑> int</span>
</code></dt>
<dd>
<div class="desc"><p>Apply the P-box permutation on the input.</p>
<p>:param inp: Integer, the input value to apply the P-box permutation on.
:return: Integer, the permuted value after applying the P-box.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def perm(self, inp: int) -&gt; int:
    &#34;&#34;&#34;
    Apply the P-box permutation on the input.

    :param inp: Integer, the input value to apply the P-box permutation on.
    :return: Integer, the permuted value after applying the P-box.
    &#34;&#34;&#34;
    ct = 0
    for i, v in enumerate(self.PBOX):
        ct |= (
            inp &gt;&gt; (
                self.BLOCK_SIZE -
                1 -
                i) &amp; 1) &lt;&lt; (
            self.BLOCK_SIZE -
            1 -
            v)
    return ct</code></pre>
</details>
</dd>
<dt id="cryptanalysis.spn.SPN.sbox"><code class="name flex">
<span>def <span class="ident">sbox</span></span>(<span>self, inp: int) ‑> int</span>
</code></dt>
<dd>
<div class="desc"><p>Apply the S-box substitution on the input.</p>
<p>:param inp: Integer, the input value to apply the S-box substitution on.
:return: Integer, the substituted value after applying the S-box.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sbox(self, inp: int) -&gt; int:
    &#34;&#34;&#34;
    Apply the S-box substitution on the input.

    :param inp: Integer, the input value to apply the S-box substitution on.
    :return: Integer, the substituted value after applying the S-box.
    &#34;&#34;&#34;
    ct, BS = 0, self.BOX_SIZE
    for i in range(self.NUM_SBOX):
        ct |= self.SBOX[(inp &gt;&gt; (i * BS)) &amp; ((1 &lt;&lt; BS) - 1)] &lt;&lt; (BS * i)
    return ct</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="cryptanalysis" href="index.html">cryptanalysis</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="cryptanalysis.spn.gen_pbox" href="#cryptanalysis.spn.gen_pbox">gen_pbox</a></code></li>
<li><code><a title="cryptanalysis.spn.rotate_left" href="#cryptanalysis.spn.rotate_left">rotate_left</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="cryptanalysis.spn.SPN" href="#cryptanalysis.spn.SPN">SPN</a></code></h4>
<ul class="two-column">
<li><code><a title="cryptanalysis.spn.SPN.expand_key" href="#cryptanalysis.spn.SPN.expand_key">expand_key</a></code></li>
<li><code><a title="cryptanalysis.spn.SPN.int_to_list" href="#cryptanalysis.spn.SPN.int_to_list">int_to_list</a></code></li>
<li><code><a title="cryptanalysis.spn.SPN.inv_perm" href="#cryptanalysis.spn.SPN.inv_perm">inv_perm</a></code></li>
<li><code><a title="cryptanalysis.spn.SPN.inv_sbox" href="#cryptanalysis.spn.SPN.inv_sbox">inv_sbox</a></code></li>
<li><code><a title="cryptanalysis.spn.SPN.list_to_int" href="#cryptanalysis.spn.SPN.list_to_int">list_to_int</a></code></li>
<li><code><a title="cryptanalysis.spn.SPN.perm" href="#cryptanalysis.spn.SPN.perm">perm</a></code></li>
<li><code><a title="cryptanalysis.spn.SPN.sbox" href="#cryptanalysis.spn.SPN.sbox">sbox</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>